tendo o modelo abaixo

// State model
module.exports = (sequelize, DataTypes) => {
  const State = sequelize.define('State', {
    ID_State: {
      type: DataTypes.INTEGER,
      primaryKey: true,
      autoIncrement: true
    },
    Name: {
      type: DataTypes.STRING(100),
      allowNull: false,
      unique: true
    },
    Acronym: {
      type: DataTypes.STRING(2),
      allowNull: false,
      unique: true
    },
    Cod_State: {
      type: DataTypes.STRING(2),
      allowNull: false,
      unique: true
    }
  }, {
    timestamps: false,
    tableName: 'States'
  });

  return State;
};

e o controller abaixo

const { State, City } = require('../models');
const yup = require('yup');

// YUP schema for State validation
const stateSchema = yup.object().shape({
  Name: yup.string().required().max(100),
  Acronym: yup.string().required().length(2),
  Cod_State: yup.string().required().length(2)
});

const stateController = {
  // Create a new state
  createState: async (req, res) => {
    try {
      const { Name, Acronym, Cod_State } = req.body;

      // Validate request body against schema
      await stateSchema.validate({ Name, Acronym, Cod_State });
  
      // Check for uniqueness constraints
      const existingState = await State.findOne({
        where: {
          [Op.or]: [
            { Name },
            { Acronym },
            { Cod_State }
          ]
        }
      });
  
      if (existingState) {
        return res.status(400).json({ error: 'A state with the provided name, acronym, or code already exists.' });
      }
      
      const newState = await State.create({ Name, Acronym, Cod_State });
      res.status(201).json(newState);
    } catch (error) {
      res.status(400).json({ error: error.message });
    }
  },

  // List all states
  listAll: async (req, res) => {
    try {
      const states = await State.findAll();
      res.json(states);
    } catch (error) {
      res.status(400).json({ error: error.message });
    }
  },

  // Get a state by ID
  getStateById: async (req, res) => {
    try {
      const { id } = req.params;
      const state = await State.findByPk(id);
      if (state) {
        res.json(state);
      } else {
        res.status(404).json({ error: 'State not found' });
      }
    } catch (error) {
      res.status(400).json({ error: error.message });
    }
  },

  // Update a state
  updateState: async (req, res) => {
    try {
      const { id } = req.params;
      const { Name, Acronym, Cod_State } = req.body;

      // Validate request body against schema
      await stateSchema.validate({ Name, Acronym, Cod_State });

      // Check for uniqueness constraints
      const existingState = await State.findOne({
        where: {
          [Op.or]: [
            { Name },
            { Acronym },
            { Cod_State }
          ],
          ID_State: { [Op.ne]: id } // Exclude the current state from the check
        }
      });

      if (existingState) {
        return res.status(400).json({ error: 'A state with the provided name, acronym, or code already exists.' });
      }

      const [updated] = await State.update({ Name, Acronym, Cod_State }, { where: { ID_State: id } });
      if (updated) {
        const updatedState = await State.findByPk(id);
        res.json(updatedState);
      } else {
        res.status(404).json({ error: 'State not found' });
      }
    } catch (error) {
      res.status(400).json({ error: error.message });
    }
  },

  // Delete a state
  deleteState: async (req, res) => {
    try {
      const { id } = req.params;

      // Check if any city is linked to this state before deleting
      const linkedCities = await City.count({ where: { ID_State: id } });
      if (linkedCities > 0) {
        return res.status(400).json({ error: 'Cannot delete state because it is referenced by one or more cities.' });
      }

      const deleted = await State.destroy({ where: { ID_State: id } });
      if (deleted) {
        res.json({ message: 'State deleted successfully' });
      } else {
        res.status(404).json({ error: 'State not found' });
      }
    } catch (error) {
      res.status(400).json({ error: error.message });
    }
  }
};

module.exports = stateController;

usando  chai (^5.1.0), jest(^29.7.0),mocha(^10.3.0) e supertest(^6.3.4),
gere os testes das actins deste controller, inclusive a checagem se os erros 
previstos estão sendo checados corretamente.

minha app esta em './' e se chama app.js, os controllers estão em ./controllers e o routes para estate é

// stateRoutes.js
const express = require('express');
const router = express.Router();
const stateController = require('../controllers/stateController');

// Middleware for authentication if needed
// const { verifyToken } = require('../middleware/authMiddleware');

router.post('/states', stateController.createState); // Create a new state
router.get('/states', stateController.listAll); // List all states
router.get('/states/:id', stateController.getStateById); // Get a state by ID
router.put('/states/:id', stateController.updateState); // Update a state
router.delete('/states/:id', stateController.deleteState); // Delete a state

module.exports = router;

para rodar o teste devmos nos autenticar

router.post('/login', sessionController.login);

const sessionController = {
  login: async (req, res) => {
    try {
      const { UserEmail, UserPassword } = req.body;
      const user = await User.findOne({ where: { UserEmail } });

      if (!user) {
        return res.status(401).json({ error: 'User not found' });
      }

      const match = await bcrypt.compare(UserPassword, user.UserPassword);

      if (!match) {
        return res.status(401).json({ error: 'Incorrect password' });
      }

      const token = jwt.sign(
        { 
          id: user.UserID, 
          ID_Company: user.ID_Company, 
          UserType: user.UserType 

        }, 
        process.env.JWT_SECRET, 
        { expiresIn: '1h' });

      res.json({ message: 'Login successful', token });
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  },

sabendo que o temos um usuario válido de email xxx@mmm.com senha 12345678 o que mudar no teste acima


tendo o seguinte model de user

// models/user.js
module.exports = (sequelize, DataTypes) => {
  const User = sequelize.define('User', {
    ID_Company: {
      type: DataTypes.INTEGER,
      allowNull: false,
      references: {
        model: 'Companies',
        key: 'ID_Company'
      }
    },
    UserID: {
      type: DataTypes.INTEGER,
      primaryKey: true,
      autoIncrement: true
    },
    UserName: {
      type: DataTypes.STRING(30),
      allowNull: false
    },
    UserEmail: {
      type: DataTypes.STRING(255),
      allowNull: false,
      unique: true,
      validate: {
        isEmail: true
      }
    },
    UserPassword: {
      type: DataTypes.STRING(255),
      allowNull: false
    },
    UserType: {
      type: DataTypes.ENUM('Root', 'Admin', 'Teacher', 'Client'),
      allowNull: false
    },
  }, {
    timestamps: false,
    tableName: 'Users'
  });

  return User;
};

e  model de company

// models/company.js
module.exports = (sequelize, DataTypes) => {
  const Company = sequelize.define('Company', {
    ID_Company: {
      type: DataTypes.INTEGER,
      primaryKey: true,
      autoIncrement: true
    },
    Name: {
      type: DataTypes.STRING,
      allowNull: false
    }
    // Outros campos relevantes para uma companhia, como endereço, CNPJ, etc.
  }, {
    tableName: 'Companies',
    timestamps: false
  });

  return Company;
};


e sabendo que 



para user




'Root', 'Admin'



tendo um arquivo .csv com
ID_Company,nome,e-mail,tipo

crie um programa para carregar a tabela de users cujo modelo é como abaixo

module.exports = (sequelize, DataTypes) => {
  const User = sequelize.define('User', {
    ID_Company: {
      type: DataTypes.INTEGER,
      allowNull: false,
      references: {
        model: 'Companies',
        key: 'ID_Company'
      }
    },
    UserID: {
      type: DataTypes.INTEGER,
      primaryKey: true,
      autoIncrement: true
    },
    UserName: {
      type: DataTypes.STRING(30),
      allowNull: false
    },
    UserEmail: {
      type: DataTypes.STRING(255),
      allowNull: false,
      unique: true,
      validate: {
        isEmail: true
      }
    },
    UserPassword: {
      type: DataTypes.STRING(255),
      allowNull: false
    },
    UserType: {
      type: DataTypes.ENUM('Root', 'Admin', 'Teacher', 'Client'),
      allowNull: false
    },
  }, {
    timestamps: false,
    tableName: 'Users'
  });

  return User;
};

o inicio do programa deve ser como abaixo

const fs = require('fs');
const csv = require('csv-parser');
const path = require('path');
const dotenv = require('dotenv');
const { Sequelize, DataTypes } = require('sequelize');
const { generatePassword, generateSalt } = require('../utils/userHelpers');

dotenv.config(); // Carrega variáveis de ambiente do arquivo .env

const env = process.env.NODE_ENV || 'development';
const config = require('../config/config.json')[env];

// Instância do Sequelize usando a configuração do nosso ambiente
const sequelize = new Sequelize(config.database, config.username, config.password, config);

// Importação dos modelos
const User = require('../models/user')(sequelize, DataTypes);


a password sera para cada usuario a primeira e segunda letra do nome, seguido de '@123456' 


As senhas são salva criptografadas o seu tamnho obtido de .env veja abaixo como


const passwordLength = parseInt(process.env.AUTO_GENERATED_PASSWORD_LENGTH) || 10; 

a geração da password de usar as funcoes (generateSalt, generatePassword) como abaixo
          const salt = generateSalt(); // Supondo que esta função está definida
          const password = generatePassword(passwordLength, salt); 

 estas funcoes estão localisadas em '../utils/userHelpers'

 inclua no código gerado 



 na rotina abaixo, retire o uso das funçoes em ../utils/userHelpers,
 e use o bcrypt para gerar a password hashed

const fs = require('fs');
const csv = require('csv-parser');
const path = require('path');
const dotenv = require('dotenv');
const { Sequelize, DataTypes } = require('sequelize');
const { generatePassword, generateSalt } = require('../utils/userHelpers');

dotenv.config(); // Carrega variáveis de ambiente do arquivo .env

const env = process.env.NODE_ENV || 'development';
const config = require('../config/config.json')[env];

// Instância do Sequelize usando a configuração do nosso ambiente
const sequelize = new Sequelize(config.database, config.username, config.password, config);

// Importação dos modelos
const User = require('../models/user')(sequelize, DataTypes);
const Teacher = require('../models/teacher')(sequelize, DataTypes);

// Definição da associação
User.hasOne(Teacher, { foreignKey: 'UserID', as: 'teacherInfo' });
Teacher.belongsTo(User, { foreignKey: 'UserID' });

const passwordLength = parseInt(process.env.AUTO_GENERATED_PASSWORD_LENGTH) || 10; 

async function loadCSV(filePath) {
  process.stdout.write('Loading Teachers <<=================\n\r')
  const results = [];
  fs.createReadStream(filePath)
    .pipe(csv())
    .on('data', (data) => results.push(data))
    .on('end', async () => {
      process.stdout.write(`${results.length} Teachers em memória\n\r`)
      var ctr=0
      for (const item of results) {
        const transaction = await sequelize.transaction();
        try {
          const salt = generateSalt(); // Supondo que esta função está definida
          const password = generatePassword(passwordLength, salt); 
          // Criação do usuário
          const newUser = await User.create({
            UserName: item.UserName,
            UserEmail: item.UserEmail,
            UserPassword: password,
            UserType: 'Teacher',
            ID_Company: item[Object.keys(item)[0]]
          }, { transaction });

          // Criação do professor associado ao usuário
          await Teacher.create({
            Name: item.Name,
            UserID: newUser.UserID,
            ID_Company: item[Object.keys(item)[0]]
          }, { transaction });

          await transaction.commit();
          ctr++

          process.stdout.write(`${ctr}\r`)
        } catch (error) {
          console.error('Error during record insertion:', error);
          await transaction.rollback();
        }
      }
      process.stdout.write(`\n${ctr}Teachers included in the DB\n\r`)
      console.log('Data loaded successfully');
    });
}

const filePath = path.join(__dirname, 'data', 'teachers.csv');
console.log(__dirname)
loadCSV(filePath);

A valor da password do User a ser inserido (hashedPassword) sera criada como abaixo                

  const userNameInitials = item.UserName.slice(0, 2).toLowerCase();
  const password = userNameInitials + '@123456'; // Custom password as described
  const hashedPassword = await bcrypt.hash(password, 10);


  Tendo o model user abaixo// models/user.js
module.exports = (sequelize, DataTypes) => {
  const User = sequelize.define('User', {
    ID_Company: {
      type: DataTypes.INTEGER,
      allowNull: false,
      references: {
        model: 'Companies',
        key: 'ID_Company'
      }
    },
    UserID: {
      type: DataTypes.INTEGER,
      primaryKey: true,
      autoIncrement: true
    },
    UserName: {
      type: DataTypes.STRING(30),
      allowNull: false
    },
    UserEmail: {
      type: DataTypes.STRING(255),
      allowNull: false,
      unique: true,
      validate: {
        isEmail: true
      }
    },
    UserPassword: {
      type: DataTypes.STRING(255),
      allowNull: false
    },
    UserType: {
      type: DataTypes.ENUM('Root', 'Admin', 'Teacher', 'Client'),
      allowNull: false
    },
  }, {
    timestamps: false,
    tableName: 'Users'
  });

  return User;
};

crie uma rotina para atualizar a password de cada user como  abaixo

  const userNameInitials = User.UserName.slice(0, 2).toLowerCase();
  const password = userNameInitials + '@123456'; // Custom password as described
  const hashedPassword = await bcrypt.hash(password, passwordLength);

  hashedPassword sera usado para alterar o campo password

  o codigo desta rotina iniciara como abaixo


const dotenv = require('dotenv');
const bcrypt = require('bcrypt');
const { Sequelize, DataTypes } = require('sequelize');

dotenv.config(); // Load environment variables from .env file

const env = process.env.NODE_ENV || 'development';
const config = require('../config/config.json')[env];

// Creating a new Sequelize instance using our configuration
const sequelize = new Sequelize(config.database, config.username, config.password, config);

// Importing models
const User = require('../models/user')(sequelize, DataTypes);

const passwordLength = parseInt(process.env.AUTO_GENERATED_PASSWORD_LENGTH) || 10; 