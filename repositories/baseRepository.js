const { showError } = require('../utils/helpers/logHelpers');
const { capitalize } = require('../utils/string/stringHelpers');

class BaseRepository {
  constructor(modelName, db) {
    if (!db) {
      throw new Error("A Database connection should be provided.");
    }
    if (!db[modelName]) {
      throw new Error(`Model '${modelName}' not found in the database.`);
    }
    
    this.db = db;
    this.model = db[modelName];
    this.modelName = modelName;
    this.fields = Object.keys(this.model.rawAttributes);
    this.primaryKey = this.fields.find(key => this.model.rawAttributes[key].primaryKey);

    this.bindMethods([
      'getModelName', 'getPrimaryKey', 'getFields', 'getFieldsExcludingPrimaryKey',
      'findById', 'countAll', 'findAll', 'findByUniqueConstraints', 'create', 'update', 'delete'
    ]);

    console.log(`${this.modelName}Repository initialized with fields: [ ${this.fields.join(', ')} ]`);
  }

  // Binds all specified methods to the instance
  bindMethods(methods) {
    methods.forEach(method => {
      if (typeof this[method] === 'function') {
        this[method] = this[method].bind(this);
      }
    });
  }

  getModelName() {
    return this.modelName;
  }

  getPrimaryKey() {
    return this.primaryKey;
  }

  getFields(includeSysFields = false) {
    return includeSysFields ? this.fields :
      this.fields.filter(key => !this.model.rawAttributes[key]._autoGenerated &&
                                !this.model.rawAttributes[key].autoIncrement &&
                                !['createdAt', 'updatedAt', 'deletedAt'].includes(key));
  }

  getFieldsExcludingPrimaryKey(includeSysFields = false) {
    return this.getFields(includeSysFields).filter(field => field !== this.primaryKey);
  }

  async findById(id, includeModels = []) {
    try {
      const options = includeModels.length > 0 ? { include: transformIncludeModels(includeModels, this.db) } : {};
      const record = await this.model.findByPk(id, options);
      return this.formatResult(record, `${this.model.name} found`, `${this.model.name} not found`);
    } catch (error) {
      return this.handleError(error, { id });
    }
  }

  async countAll(filter = {}) {
    try {
      const count = await this.model.count({ where: filter });
      return this.formatResult(count, `${count} records found`);
    } catch (error) {
      return this.handleError(error, { filter });
    }
  }

  async findAll(filter = {}, includeModels = [], offset = 0, limit = 10) {
    try {
      const options = { where: filter };
      const totalCount = await this.model.count(options);

      if (includeModels.length > 0) {
        options.include = transformIncludeModels(includeModels, this.db);
      }
      if (offset !== 0 && limit !== 0) {
        Object.assign(options, { offset, limit });
      }

      const records = await this.model.findAll(options);
      return this.formatResult(
        { records: records.map(r => r.get()), count_total: totalCount },
        `${records.length} records retrieved`
      );
    } catch (error) {
      return this.handleError(error, { filter, includeModels, offset, limit });
    }
  }

  async findByUniqueConstraints(constraints, excludeId = null) {
    try {
      // constraints = empty array => no testing is necessary
      if (!Array.isArray(constraints) || constraints.length === 0) {
        return this.formatResult(null,`${this.modelName} no unique testing is necessary.`);
      }
  
      const whereClause = { [this.db.Sequelize.Op.or]: constraints };
  
      if (excludeId) {
        whereClause[this.primaryKey] = { [this.db.Sequelize.Op.ne]: excludeId };
      }
  
      const record = await this.model.findOne({ where: whereClause });
      return this.formatResult(
        record,
          record ? `A record matching ${JSON.stringify(constraints)} already exists.`
                 : `No record found for ${JSON.stringify(constraints)}.`
        );
    } catch (error) {
      return this.handleError(error, { constraints, excludeId });
    }
  }

  async create(data, transaction = null) {
    try {
      const resultingData = await this.model.create(data, transaction ? { transaction } : {});
      return this.formatResult(resultingData.get(), `${this.model.name} successfully created`);
    } catch (error) {
      return this.handleError(error, { data });
    }
  }

  async update(data, transaction = null) {
    try {
      const id = data[this.primaryKey];
      if (!id) throw new Error(`Primary key (${this.primaryKey}) is required for update`);

      const updatedData = { ...data };
      delete updatedData[this.primaryKey];

      const [affectedRows] = await this.model.update(updatedData, {
        where: { [this.primaryKey]: id },
        ...(transaction && { transaction }),
      });

      if (affectedRows !== 1) {
        return this.formatResult(null, `${this.model.name} not found or multiple records affected`);
      }

      return this.formatResult({ [this.primaryKey]: id, ...updatedData }, `${this.model.name} successfully updated`);
    } catch (error) {
      return this.handleError(error, { data });
    }
  }

  async delete(data, transaction = null) {
    try {
      const { id } = data;
      if (!id) {
        return this.formatResult(null, `Can't delete ${this.model.name} without a valid id`);
      }
    
      const affectedRows = await this.model.destroy({ where: { [this.primaryKey]: id }, ...(transaction && { transaction }) });

      if (affectedRows !== 1) {
        return this.formatResult(null, `${this.model.name} not found or multiple records affected`);
      }

      return this.formatResult(null, `${this.model.name} deleted successfully`);
    } catch (error) {
      return this.handleError(error, { id });
    }
  }

  async transaction() {
    return this.db.sequelize.transaction();
  }

  // General error handler
  handleError(error, context) {
    showError(error, context);
    return { success: false, message: `Error in ${this.model.name}: ${error.message}`, data: {}, unexpected: true };
  }

  // Standardized success/failure response
  formatResult(data, successMessage, failureMessage = null) {
    return {
      success: Boolean(data),
      message: data ? successMessage : failureMessage || "Operation failed",
      data: data || {},
      unexpected: false,
    };
  }
}

// Helper function for includes
function transformIncludeModels(includeModels, db) {
  return includeModels
    .filter(item => item.model && (db[item.model] || db[capitalize(item.model)]))
    .map(item => ({
      model: db[item.model] ? db[item.model] : db[capitalize(item.model)],
      ...(item.attributes ? { attributes: item.attributes } : {}),
    }));
}

module.exports = BaseRepository;